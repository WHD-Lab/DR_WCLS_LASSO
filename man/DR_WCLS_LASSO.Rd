% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/UI_function_grids.R
\name{DR_WCLS_LASSO}
\alias{DR_WCLS_LASSO}
\title{DR_WCLS_LASSO}
\usage{
DR_WCLS_LASSO(
  data,
  fold,
  ID,
  time,
  Ht,
  St,
  At,
  prob,
  outcome,
  method_pseu,
  lam = NULL,
  noise_scale = NULL,
  splitrat = 0.8,
  virtualenv_path = "",
  beta = NULL,
  level = 0.9,
  core_num = NULL,
  max_tol = 10^{
     -3
 },
  varSelect_program = "Python",
  standardize_x = TRUE,
  standardize_y = TRUE
)
}
\arguments{
\item{data}{A data frame with one row per decision time (raw data; no pseudo-outcomes).}

\item{fold}{Number of folds used when estimating nuisance functions for the pseudo-outcome.}

\item{ID}{Column name of the participant identifier.}

\item{time}{Column name of the time-in-study (decision point).}

\item{Ht}{A vector specifying history features.}

\item{St}{A vector specifying moderator features.}

\item{At}{Column name of the treatment indicator.}

\item{prob}{Column name of the design probability \eqn{p_t(A_t=1 \mid H_t)}.}

\item{outcome}{Column name of the outcome.}

\item{method_pseu}{ML method used to estimate nuisance functions for the
pseudo-outcome. One of \code{"CVLASSO"}, \code{"RandomForest"}, \code{"GradientBoosting"}.}

\item{lam}{Penalty value for randomized LASSO; if \code{NULL}, a default is used. Default is
\eqn{\sqrt{2n* logp} \rho sd(y)} where \eqn{\rho}
is the split rate and \eqn{n} is the number of rows.}

\item{noise_scale}{Gaussian noise added to the objective.
Default is \eqn{\sqrt{\frac{1-\rho}{\rho}\, n}\,\mathrm{sd}(y)} where \eqn{\rho}
is the split rate and \eqn{n} is the number of rows.}

\item{splitrat}{Data splitting rate \eqn{\rho}; used only if \code{noise_scale} or \code{lam} is \code{NULL}.}

\item{virtualenv_path}{Path to a Python virtual environment (for \code{reticulate})
when \code{varSelect_program = "Python"}.}

\item{beta}{True coefficients (for simulation use only).}

\item{level}{Confidence level (e.g., \code{0.90} for a 90\% interval).}

\item{core_num}{Number of cores to use for parallel computation when compute pseudo-outcome.}

\item{max_tol}{Maximum tolerance for the pivot error. Default \eqn{10^{-3}}.}

\item{varSelect_program}{\code{"Python"} (requires a valid \code{virtualenv_path}) or \code{"R"}.}

\item{standardize_x}{Logical flag for design matrix standardization, prior to the model selection.}

\item{standardize_y}{Logical flag for outcome standardization, prior to the model selection.}
}
\value{
\describe{
\item{E}{Selected variables.}
\item{GEE_est}{GEE estimates without adjusting for selection events.}
\item{lowCI}{lower bound of confidence interval.}
\item{upperCI}{upper bound of confidence interval.}
\item{prop_low}{the exact quantile for the lower bound of confidence interval.}
\item{prop_up}{the exact quantile for the upper bound of confidence interval.}
\item{p_value}{P-values for selected variables.}
\item{post_true}{condition on the selection events, the true values for parameter \eqn{\beta_E}
if simulation is conducted and true \eqn{\beta} values are provided; Otherwise, this value will not be
present}.
\item{true_signal}{logical value indicating whether the selected parameter is one of the true signals
if simulation is conducted and true \eqn{\beta} values are provided; Otherwise, this value will not be
present}
}
}
\description{
Fit a basic doubly robust weighted centered least squares (DR-WCLS)
model with variable selection.
}
\details{
The function generates a pseudo-outcome,
performs variable selection, then conducts post-selective inference to obtain
valid confidence intervals adjusted for data dependent model selection.
}
\examples{
  sim_data = generate_dataset(N = 1000, T = 40, P = 50, sigma_residual = 1.5, sigma_randint = 1.5, main_rand = 3, rho = 0.7,
  beta_logit = c(-1, 1.6 * rep(1/50, 50)), model = ~ state1 + state2 + state3 + state4,
  beta = matrix(c(-1, 1.7, 1.5, -1.3, -1),ncol = 1),
  theta1 = 0.8)
  Ht = unlist(lapply(1:50, FUN = function(X) paste0("state",X)))
  St = unlist(lapply(1:25, FUN = function(X) paste0("state",X)))

  UI_return = DR_WCLS_LASSO(data = sim_data,
  fold = 5, ID = "id",
  time = "decision_point",
  Ht = Ht, St = St, At = "action",
  prob = "prob", outcome = "outcome",
  method_pseu = "CVLASSO", lam = NULL, noise_scale = NULL, splitrat = 0.7,
  varSelect_program = "R", standardize_x = F, standardize_y = F)




}
